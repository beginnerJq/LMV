module.exports = "\n#include <depth_texture>\n#define USE_MIPMAP 1\nuniform float cameraNear;\nuniform float cameraFar;\nuniform vec2 size;\nuniform vec2 resolution;\nuniform float lumInfluence;\nvarying vec2 vUv;\n#define NUM_SAMPLES (17)\n#define LOG_MAX_OFFSET (3)\n#define MAX_MIP_LEVEL (5)\n#define NUM_SPIRAL_TURNS (5)\n#define MIN_RADIUS (3.0)\n#define TAU 6.28318530718\nuniform float           projScale;\n#ifdef USE_MIPMAP\nuniform sampler2D tDepth_mip1;\nuniform sampler2D tDepth_mip2;\nuniform sampler2D tDepth_mip3;\nuniform sampler2D tDepth_mip4;\nuniform sampler2D tDepth_mip5;\n#endif\nuniform float radius;\nuniform float bias;\nuniform float intensity;\nvec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){\n    float alpha = float(float(sampleNumber) + 0.5) * (1.0 / float(NUM_SAMPLES));\n    float angle = alpha * (float(NUM_SPIRAL_TURNS) * TAU) + spinAngle;\n    ssR = alpha;\n    return vec2(cos(angle), sin(angle));\n}\nfloat CSZToKey(float z) {\n    return clamp( (z+cameraNear) / (cameraNear-cameraFar), 0.0, 1.0);\n}\nvoid packKey(float key, out vec2 p) {\n    float temp = floor(key * 255.0);\n    p.x = temp * (1.0 / 255.0);\n    p.y = key * 255.0 - temp;\n}\n#include <pack_depth>\nfloat unpackDepthNearFar( const in vec4 rgba_depth ) {\n    float depth = unpackDepth( rgba_depth );\n    if (depth == 0.0)\n        return -cameraFar * 1.0e10;\n    return depth * (cameraNear - cameraFar) - cameraNear;\n}\nvec3 reconstructCSFaceNormal(vec3 C) {\n    return normalize(cross(dFdy(C), dFdx(C)));\n}\nvec3 reconstructNonUnitCSFaceNormal(vec3 C) {\n    return cross(dFdy(C), dFdx(C));\n}\nvec3 getPosition(ivec2 ssP, float depth) {\n    vec3 P;\n    P = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);\n    return P;\n}\nvec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {\n    ivec2 ssP = ivec2(ssR * unitOffset) + ssC;\n    vec3 P;\n#ifdef _LMVWEBGL2_\n#ifdef USE_MIPMAP\n    int mipLevel = clamp(int(floor(log2(ssR))) - LOG_MAX_OFFSET, 0, MAX_MIP_LEVEL);\n    if (mipLevel == 0) {\n        P.z = texelFetch(tDepth, ssP, 0).z;\n        if (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n    }\n    else if (mipLevel == 1) {\n        ivec2 mipP = clamp(ssP >> mipLevel, ivec2(0), textureSize(tDepth_mip1, 0) - ivec2(1));\n        P.z = unpackDepthNearFar(texelFetch(tDepth_mip1, mipP, 0));\n    } else if (mipLevel == 2) {\n        ivec2 mipP = clamp(ssP >> mipLevel, ivec2(0), textureSize(tDepth_mip2, 0) - ivec2(1));\n        P.z = unpackDepthNearFar(texelFetch(tDepth_mip2, mipP, 0));\n    } else if (mipLevel == 3) {\n        ivec2 mipP = clamp(ssP >> mipLevel, ivec2(0), textureSize(tDepth_mip3, 0) - ivec2(1));\n        P.z = unpackDepthNearFar(texelFetch(tDepth_mip3, mipP, 0));\n    } else if (mipLevel == 4) {\n        ivec2 mipP = clamp(ssP >> mipLevel, ivec2(0), textureSize(tDepth_mip4, 0) - ivec2(1));\n        P.z = unpackDepthNearFar(texelFetch(tDepth_mip4, mipP, 0));\n    } else if (mipLevel == 5) {\n        ivec2 mipP = clamp(ssP >> mipLevel, ivec2(0), textureSize(tDepth_mip5, 0) - ivec2(1));\n        P.z = unpackDepthNearFar(texelFetch(tDepth_mip5, mipP, 0));\n    }\n#else\n    P.z = texelFetch(tDepth, ssP, 0).z;\n    if (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n#endif\n#else\n    vec2 screenUV = (vec2(ssP) + vec2(0.5)) * resolution;\n#ifdef USE_MIPMAP\n    int mipLevel = int(max(0.0, min(floor(log2(ssR)) - float(LOG_MAX_OFFSET), float(MAX_MIP_LEVEL))));\n    if (mipLevel == 0) {\n        P.z = texture2D(tDepth, screenUV).z;\n        if (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n    }\n    else if (mipLevel == 1)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip1, screenUV));\n    else if (mipLevel == 2)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip2, screenUV));\n    else if (mipLevel == 3)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip3, screenUV));\n    else if (mipLevel == 4)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip4, screenUV));\n    else if (mipLevel == 5)\n        P.z = unpackDepthNearFar(texture2D(tDepth_mip5, screenUV));\n#else\n    P.z = texture2D(tDepth, screenUV).z;\n    if (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n#endif\n#endif\n    P = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);\n    return P;\n}\nfloat sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {\n    float ssR;\n    vec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);\n    ssR = max(0.75, ssR * ssDiskRadius);\n    vec3 Q = getOffsetPosition(ssC, unitOffset, ssR);\n    vec3 v = Q - C;\n    float vv = dot(v, v);\n    float vn = dot(v, n_C);\n    const float epsilon = 0.001;\n    float angAdjust = mix(1.0, max(0.0, 1.5 * n_C.z), 0.35);\n#define HIGH_QUALITY\n#ifdef HIGH_QUALITY\n    float f = max(1.0 - vv / (radius * radius), 0.0); return angAdjust * f * max((vn - bias) / sqrt(epsilon + vv), 0.0);\n#else\n    float f = max(radius * radius - vv, 0.0); return angAdjust * f * f * f * max((vn - bias) / (epsilon + vv), 0.0);\n#endif\n}\nconst bool useNoise = true;\nfloat getRandomAngle(vec2 pos) {\n    float dt= dot(pos ,vec2(12.9898,78.233));\n    return TAU * fract(sin(mod(dt,3.14)) * 43758.5453);\n}\nvoid main() {\n    ivec2 ssC = ivec2(gl_FragCoord.xy);\n    vec4 nrmz = texture2D(tDepth, vUv);\n    if (nrmz.z == 0.0) {\n        gl_FragColor.r = 1.0;\n        gl_FragColor.a = 0.0;\n        packKey(1.0, gl_FragColor.gb);\n        return;\n    }\n    vec3 C = getPosition(ssC, nrmz.z);\n    packKey(CSZToKey(C.z), gl_FragColor.gb);\n    float ssDiskRadius = -projScale * radius / mix(C.z, -1.0, isOrtho);\n    float A;\n    if (ssDiskRadius <= MIN_RADIUS) {\n        A = 1.0;\n    } else {\n        float sum = 0.0;\n        float randomPatternRotationAngle = getRandomAngle(vUv);\n        vec3 n_C = vec3(nrmz.x, nrmz.y, sqrt(1.0 - dot(nrmz.xy, nrmz.xy)));\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 0, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 1, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 2, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 3, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 4, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 5, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 6, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 7, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 8, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 9, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 10, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 11, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 12, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 13, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 14, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 15, randomPatternRotationAngle);\n        sum += sampleAO(ssC, C, n_C, ssDiskRadius, 16, randomPatternRotationAngle);\n        float intensityDivR6 = intensity / pow(radius, 6.0);\n#ifdef HIGH_QUALITY\n        A = pow(max(0.0, 1.0 - sqrt(sum * (3.0 / float(NUM_SAMPLES)))), intensity);\n#else\n        A = max(0.0, 1.0 - sum * intensityDivR6 * (5.0 / float(NUM_SAMPLES)));\n        A = (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n#endif\n        if (abs(dFdx(C.z)) < 0.02) {\n            A -= dFdx(A) * (mod(float(ssC.x), 2.0) - 0.5);\n        }\n        if (abs(dFdy(C.z)) < 0.02) {\n            A -= dFdy(A) * (mod(float(ssC.y), 2.0) - 0.5);\n        }\n        A = mix(1.0, A, clamp(ssDiskRadius - MIN_RADIUS,0.0,1.0));\n    }\n    gl_FragColor.r = A;\n    gl_FragColor.a = 1.0;\n}\n";